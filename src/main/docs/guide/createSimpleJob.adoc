Since scheduling is native functionality. Just execute:

[source, bash]
----
./grailsw create-service HelloWorldJob
----

This will create the file `grails-app/services/demo/HelloWorldJobService.groovy` with a empty template method.

The very basic skeleton of a Schwartz Job is:

[source, groovy]
.grails-app/services/demo/HelloWorldJobService.groovy
----
@Transactional // <1>
class HelloWorldJobService {

    def serviceMethod() {
        // <2>
    }
}
----
<1> By default services are `Transactional`
<2> The job logic goes here


Let's modify the previous code and add the following:

[source, groovy]
.grails-app/services/demo/HelloWorldJobService.groovy
----
include::{sourceDir}/grails-app/services/demo/HelloWorldJobService.groovy[]
----
<1> Remove `@Transactional` as this service does not require transactions. Add `@CompileStatic` for performance and `@Slf4j` for logging
<2> Force service to initialize, Without forcing the service to be initialized the jobs will not execute
<3> Create trigger every 10 seconds
<4> Create another trigger every 45 seconds with an initial delay of 5 seconds (5000 millis)

Now start the application:

[source, bash]
----
./gradlew bootRun
----

And after a few seconds you will see the following output:

[source, bash]
----
Simple Job every 45 seconds :14/2/2018 02:06:50 # <1>
Simple Job every 10 seconds :14/2/2018 02:06:55 # <2>
Simple Job every 10 seconds :14/2/2018 02:07:05 # <3>
Simple Job every 10 seconds :14/2/2018 02:07:15
Simple Job every 10 seconds :14/2/2018 02:07:25
Simple Job every 45 seconds :14/2/2018 02:07:35 # <4>
Simple Job every 10 seconds :14/2/2018 02:07:35
----
<1> First execution of 10 seconds job just after the application starts
<2> The 45 seconds job just starts 5 seconds after the app starts. See `startDelay` in the trigger configuration.
<3> Second execution of 10 seconds job just 10 seconds after the first execution
<4> Second execution of 45 seconds job just 45 seconds after the first execution